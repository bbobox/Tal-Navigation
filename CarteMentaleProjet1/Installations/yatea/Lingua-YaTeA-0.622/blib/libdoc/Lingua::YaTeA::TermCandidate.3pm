.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lingua::YaTeA::TermCandidate 3pm"
.TH Lingua::YaTeA::TermCandidate 3pm "2015-01-16" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Lingua::YaTeA::TermCandidate \- Perl extension for Term Candidate
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Lingua::YaTeA::TermCandidate;
\&  Lingua::YaTeA::TermCandidate\->new();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a representation of a term candidate.  Each
term candidate is described by its identifier (\f(CW\*(C`ID\*(C'\fR), an internal key
\&\f(CW\*(C`KEY\*(C'\fR, the minimal head of the term candidate \f(CW\*(C`HEAD\*(C'\fR, the list of
word components \f(CW\*(C`WORDS\*(C'\fR, its list of occurrences \f(CW\*(C`OCCURRENCES\*(C'\fR, the
reliability \f(CW\*(C`RELIABILITY\*(C'\fR, is status as term \f(CW\*(C`TERM_STATUS\*(C'\fR
(according to the configuration, phrase recognised as term candidate
can be a term or not \- the default value is 0), the reference to the
original phrase in the corpus \f(CW\*(C`ORIGINAL_PHRASE\*(C'\fR, the associated
weights that can be considered as relevancy measures \f(CW\*(C`WEIGHTS\*(C'\fR, its
root node \f(CW\*(C`ROOT\*(C'\fR, the information whether the term if a maximal noun
phrase \f(CW\*(C`MNP_STATUS\*(C'\fR (the default value is 0. a term candidate is
considered as maximal noun phrase if at least one occurrence is a
maximal noun phrase).
.PP
The key of the term candidate is the concatenation of the inflected
form, the postag list and the lemma (separated by the character '~').
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&    new();
.Ve
.PP
The methord creates a new object of term candidate.
.SS "\fIsetRoot()\fP"
.IX Subsection "setRoot()"
.Vb 1
\&    setRoot();
.Ve
.PP
The method sets the \f(CW\*(C`ROOT\*(C'\fR field and returns it.
.SS "\fIgetRoot()\fP"
.IX Subsection "getRoot()"
.Vb 1
\&    getRoot();
.Ve
.PP
The method returns the \f(CW\*(C`ROOT\*(C'\fR field.
.SS "\fIsetTermStatus()\fP"
.IX Subsection "setTermStatus()"
.Vb 1
\&    setTermStatus();
.Ve
.PP
The method sets the \f(CW\*(C`TERM_STATUS\*(C'\fR field and returns it.
.SS "\fIgetTermStatus()\fP"
.IX Subsection "getTermStatus()"
.Vb 1
\&    getTermStatus();
.Ve
.PP
The method returns the \f(CW\*(C`TERM_STATUS\*(C'\fR field.
.SS "\fIisTerm()\fP"
.IX Subsection "isTerm()"
.Vb 1
\&    isTerm();
.Ve
.PP
This methods indicates if the term candidate has the term status or
not.
.SS "\fIgetLength()\fP"
.IX Subsection "getLength()"
.Vb 1
\&    getLength();
.Ve
.PP
This method returns the number of words composing the phrase.
.SS "\fIaddWord()\fP"
.IX Subsection "addWord()"
.Vb 1
\&    addWord($node, $wordlist);
.Ve
.PP
This method adds a word from the word list \f(CW$wordlist\fR and referred
by the node \f(CW$node\fR.
.SS "\fIaddOccurrence()\fP"
.IX Subsection "addOccurrence()"
.Vb 1
\&    addOccurrence($term_occurrence);
.Ve
.PP
This method adds the term occurrence (\f(CW$term_occurrence\fR) to the
current term candidate and indicates if it's a maximal noun phrase
(field \f(CW\*(C`MNP_STATUS\*(C'\fR).
.SS "\fIaddOccurrences()\fP"
.IX Subsection "addOccurrences()"
.Vb 1
\&    addOccurrences($term_occurrence_list);
.Ve
.PP
This method adds the term occurrences from the list
\&\f(CW$term_occurrence_list\fR (which is a reference to an array).
.SS "\fIgetKey()\fP"
.IX Subsection "getKey()"
.Vb 1
\&    getKey();
.Ve
.PP
This method returns the key of the term candidate.
.SS "\fIgetID()\fP"
.IX Subsection "getID()"
.Vb 1
\&    getID();
.Ve
.PP
This method returns the identifier of the term candidate.
.SS "\fIgetMNPStatus()\fP"
.IX Subsection "getMNPStatus()"
.Vb 1
\&    getMNPStatus();
.Ve
.PP
This method indicates if the term candidate is maximal noun phrase or
not.
.SS "\fIeditKey()\fP"
.IX Subsection "editKey()"
.Vb 1
\&    ediKey($string);
.Ve
.PP
This method allows to modify the key of the current term candidate by
adding the string \f(CW$string\fR.
.SS "\fIsetHead()\fP"
.IX Subsection "setHead()"
.Vb 1
\&    setHead();
.Ve
.PP
This method sets the minimal head of the term candidate by searching
it in the parsing tree of the phrase.
.SS "\fIgetHead()\fP"
.IX Subsection "getHead()"
.Vb 1
\&    getHead();
.Ve
.PP
This method returns the minimal head of the term candidate.
.SS "\fIsetWeight()\fP"
.IX Subsection "setWeight()"
.Vb 1
\&    setWeight($weight_name, $weight);
.Ve
.PP
This method sets the weight \f(CW\*(C`$<weight_name\*(C'\fR with the weight value
\&\f(CW$weight\fR.
.SS "\fIgetWeight()\fP"
.IX Subsection "getWeight()"
.Vb 1
\&    getWeight($weight_name);
.Ve
.PP
This method returns the weight value of the weight \f(CW\*(C`$<weight_name\*(C'\fR.
.SS "\fIsetWeights()\fP"
.IX Subsection "setWeights()"
.Vb 1
\&    setWeights($weight_list);
.Ve
.PP
This method sets a list of weights referred by the hash table
\&\f(CW\*(C`weight_list\*(C'\fR where the key is the weight name and the value is the
weight value.
.SS "\fIgetWeights()\fP"
.IX Subsection "getWeights()"
.Vb 1
\&    getWeights();
.Ve
.PP
This method returns the list of weights i.e. a hash table where the
key is the weight name and the value is the weight value.
.SS "\fIgetWeightNames()\fP"
.IX Subsection "getWeightNames()"
.Vb 1
\&    getWeightNames();
.Ve
.PP
The method returns the list of the weight names that are instanciated,
as an array.
.SS "\fIgetWords()\fP"
.IX Subsection "getWords()"
.Vb 1
\&    getWords();
.Ve
.PP
The mathod returns the list of the words that are components of the
term candidate.
.SS "\fIgetword()\fP"
.IX Subsection "getword()"
.Vb 1
\&    getWord($index);
.Ve
.PP
The method returns the word at the position \f(CW\*(C`
index\*(C'\fR in the list of the components of the term candidate.
.SS "\fIgetOccurrences()\fP"
.IX Subsection "getOccurrences()"
.Vb 1
\&    getOccurrences();
.Ve
.PP
This method returns the list of the occurrences of the term candidate, as an array reference.
.SS "\fIbuildLinguisticInfos()\fP"
.IX Subsection "buildLinguisticInfos()"
.Vb 1
\&    buildLinguisticInfos($tagset);
.Ve
.PP
The method returns the inflected form, the postag list and and the
lemma of the term candidate as an array (each informationn is the
concatenation of the word information).
.SS "\fIgetIF()\fP"
.IX Subsection "getIF()"
.Vb 1
\&    getIF();
.Ve
.PP
The method returns the inflected form of the term candidate.
.SS "\fIgetLF()\fP"
.IX Subsection "getLF()"
.Vb 1
\&    getLF();
.Ve
.PP
The method returns the canonical form (lemma) of the term candidate.
.SS "\fIgetPOS()\fP"
.IX Subsection "getPOS()"
.Vb 1
\&    getPOS();
.Ve
.PP
The method returns the list of the part-of-speech tags of the term
candidate.
.SS "\fIgetFrequency()\fP"
.IX Subsection "getFrequency()"
.Vb 1
\&    getFrequency();
.Ve
.PP
The method returns the frequency of the term candidate, i.e. the
number of occurrences of the term candidate.
.SS "\fIsetReliability()\fP"
.IX Subsection "setReliability()"
.Vb 1
\&    setReliability($reliability);
.Ve
.PP
The method sets the reliability of the term candidate.
.SS "\fIgetReliability()\fP"
.IX Subsection "getReliability()"
.Vb 1
\&    getReliability();
.Ve
.PP
The method returns the reliability of the term candidate.
.SS "\fIgetOriginalPhrase()\fP"
.IX Subsection "getOriginalPhrase()"
.Vb 1
\&    getOriginalPhrase();
.Ve
.PP
The method returns the original phrase issued from the corpus.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sophie Aubin and Thierry Hamon. Improving Term Extraction with
Terminological Resources. In Advances in Natural Language Processing
(5th International Conference on \s-1NLP\s0, FinTAL 2006). pages
380\-387. Tapio Salakoski, Filip Ginter, Sampo Pyysalo, Tapio Pahikkala
(Eds). August 2006. \s-1LNAI\s0 4139.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thierry Hamon <thierry.hamon@univ\-paris13.fr> and Sophie Aubin <sophie.aubin@lipn.univ\-paris13.fr>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005 by Thierry Hamon and Sophie Aubin
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
