.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lingua::YaTeA::ForbiddenStructureStartOrEnd 3pm"
.TH Lingua::YaTeA::ForbiddenStructureStartOrEnd 3pm "2015-01-16" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Lingua::YaTeA::ForbiddenStructureStartOrEnd \- Perl extension for forbidden
structures in at the start or end position of a chunk.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Lingua::YaTeA::ForbiddenStructureStartOrEnd;
\&  Lingua::YaTeA::ForbiddenStructureStartOrEnd\->new(\e@infos_a, $triggerSet);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module describes the forbidden structures that can be used in the start or end
position in the chunk. This is a specialisation of the
\&\f(CW\*(C`Lingua::YaTeA::ForbiddenStructure\*(C'\fR module. Two fields are added:
.IP "\(bu" 4
\&\f(CW\*(C`POSITION\*(C'\fR: the field contains the position of the forbiedden structure (\f(CW\*(C`START\*(C'\fR or \f(CW\*(C`END\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`ITEMS\*(C'\fR: this field contains the reference of the array of the
linguistic items.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&    new($infos_a, $triggerSet);
.Ve
.PP
The method creates a forbidden structure that can be found at the
start or end position of a chunk. The forbidden structure is defined
from the array given by reference \f(CW$infos_a\fR.  All fields are set.  A
trigger is added to the trigger Set \f(CW\*(C`triggerSet\*(C'\fR.
.SS "\fIgetFirstItem()\fP"
.IX Subsection "getFirstItem()"
.Vb 1
\&    getFirstItem();
.Ve
.PP
The method returns the first item of the linguistic item set.
.SS "\fIgetItemSet()\fP"
.IX Subsection "getItemSet()"
.Vb 1
\&    getItemSet()
.Ve
.PP
The method returns the linguistic item set.
.SS "\fIparse()\fP"
.IX Subsection "parse()"
.Vb 1
\&    parse($string);
.Ve
.PP
The method parses the pattern of the forbidden structure \f(CW$string\fR
and returns the \f(CW$form\fR of the forbidden structure and the
corresponding regular expression.
.SS "\fIgetItem()\fP"
.IX Subsection "getItem()"
.Vb 1
\&    getItem($index);
.Ve
.PP
The method returns the linguistic item at he index \f(CW$index\fR.
.SS "\fIisStart()\fP"
.IX Subsection "isStart()"
.Vb 1
\&    isStart();
.Ve
.PP
The method indicates if the forbidden structure should be used in the
start position. It returns 1 if yes.
.SS "\fIisEnd()\fP"
.IX Subsection "isEnd()"
.Vb 1
\&    isEnd();
.Ve
.PP
The method indicates if the forbidden structure should be used in the
end position. It returns 1 if yes.
.SS "\fIgetPosition()\fP"
.IX Subsection "getPosition()"
.Vb 1
\&    getPosition()
.Ve
.PP
The method returns the position if the forbidden structure (\f(CW\*(C`START\*(C'\fR
or \f(CW\*(C`END\*(C'\fR).
.SS "\fIapply()\fP"
.IX Subsection "apply()"
.Vb 1
\&    apply($word_a);
.Ve
.PP
This method applies the given forbidden structure of the array of
words given by reference \f(CW$word_a\fR.
.SS "\fIprint()\fP"
.IX Subsection "print()"
.Vb 1
\&    print();
.Ve
.PP
This method prints the description of the forbidden structure,
i.e. its form and its position.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sophie Aubin and Thierry Hamon. Improving Term Extraction with
Terminological Resources. In Advances in Natural Language Processing
(5th International Conference on \s-1NLP\s0, FinTAL 2006). pages
380\-387. Tapio Salakoski, Filip Ginter, Sampo Pyysalo, Tapio Pahikkala
(Eds). August 2006. \s-1LNAI\s0 4139.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thierry Hamon <thierry.hamon@univ\-paris13.fr> and Sophie Aubin <sophie.aubin@lipn.univ\-paris13.fr>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005 by Thierry Hamon and Sophie Aubin
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
