.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lingua::YaTeA::TestifiedTerm 3pm"
.TH Lingua::YaTeA::TestifiedTerm 3pm "2015-01-16" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Lingua::YaTeA::TestifiedTerm \- Perl extension for Testified Term
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Lingua::YaTeA::TestifiedTerm;
\&  Lingua::YaTeA::TestifiedTerm\->new(num_content_words,$words_a,$tag_set,$source,$match_type);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module implements a representation of the testified terms,
i.e. terms from a terminological resource. Those testified terms are
used to find corresponding terms in the corpus. Each testified term is
described by its identifier (\f(CW\*(C`ID\*(C'\fR), its inflected form \f(CW\*(C`IF\*(C'\fR, its
list of part-of-speech tags \f(CW\*(C`POS\*(C'\fR, its lemma \f(CW\*(C`LF\*(C'\fR, the
terminological source \f(CW\*(C`SOURCE\*(C'\fR, the list of word components \f(CW\*(C`WORDS\*(C'\fR,
the regular expression used to identify it in the corpus (\f(CW\*(C`REG_EXP\*(C'\fR),
the indication whether the testified term is found or not (\f(CW\*(C`FOUND\*(C'\fR),
its list of occurrences \f(CW\*(C`OCCURRENCES\*(C'\fR and the list of the word index
entries (\f(CW\*(C`INDEX_SET\*(C'\fR).
.PP
The three information \f(CW\*(C`IF\*(C'\fR, \f(CW\*(C`POS\*(C'\fR and \f(CW\*(C`LF\*(C'\fR are computed from the
information issued from their word components.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&    new($num_content_words,$words_a,$tag_set,$source,$match_type);
.Ve
.PP
This method creates a new object representing a testified term. It
sets the fields \f(CW\*(C`IF\*(C'\fR, \f(CW\*(C`POS\*(C'\fR, \f(CW\*(C`LF\*(C'\fR, \f(CW\*(C`REG_EXP\*(C'\fR, \f(CW\*(C`INDEX_SET\*(C'\fR and
\&\f(CW\*(C`SOURCE\*(C'\fR. \f(CW$words_a\fR and \f(CW$tag_set\fR are used to initialise the
lignuistic information (\f(CW\*(C`IF\*(C'\fR, \f(CW\*(C`POS\*(C'\fR, \f(CW\*(C`LF\*(C'\fR). \f(CW$source\fR initialises
the \f(CW\*(C`SOUCE\*(C'\fR field. \f(CW$mach_type\fR defines the type of matching for
finding the terms in the corpus.
.SS "\fIisInLexicon()\fP"
.IX Subsection "isInLexicon()"
.Vb 1
\&    isInLexicon($filtering_lexicon_h, $match_type);
.Ve
.PP
This method checks if all the words of a testified term appear in the
lexicon of the text (\f(CW$filtering_lexicon_h\fR) according to the
matching type \f(CW$match_type\fR: \f(CW\*(C`loose\*(C'\fR (each word matches either a
inflected form or a lemmatised form) \f(CW\*(C`strict\*(C'\fR (each word matches a
inflected form with the correct Part-of-Speech tag) \f(CW\*(C`default\*(C'\fR (each
word mathces a inflected form). The method returns 1 if all the words
of the testified term are found in the lexicon, otherwise it returns 0.
.PP
\&\f(CW$filtering_lexicon_h\fR is a hash table containing the inflected
forms, the lemmatised form and the concatenation of the inflected form
and the Partof-speech tag (separated by a \f(CW\*(C`~\*(C'\fR character) of each word
in the text.
.SS "\fIbuildLinguisticInfos()\fP"
.IX Subsection "buildLinguisticInfos()"
.Vb 1
\&    buildLinguisticInfos($words, $tagset);
.Ve
.PP
The method returns the inflected form, the postag list and the lemma
of the term candidate as an array (each informationn is the
concatenation of the word information found in the array \f(CW$words\fR and
the Part-of-Speech tags \f(CW$tagset\fR).
.SS "\fIgetWords()\fP"
.IX Subsection "getWords()"
.Vb 1
\&    getWords();
.Ve
.PP
The mathod returns the list of the words that are components of the
term candidate.
.SS "\fIsetIF()\fP"
.IX Subsection "setIF()"
.Vb 1
\&    setIF();
.Ve
.PP
The method sets the inflected form of the term candidate.
.SS "\fIsetPOS()\fP"
.IX Subsection "setPOS()"
.Vb 1
\&    setPOS();
.Ve
.PP
The method sets the list of the part-of-speech tags of the term
candidate.
.SS "\fIsetLF()\fP"
.IX Subsection "setLF()"
.Vb 1
\&    setLF();
.Ve
.PP
The method sets the canonical form (lemma) of the term candidate.
.SS "\fIgetIF()\fP"
.IX Subsection "getIF()"
.Vb 1
\&    getIF();
.Ve
.PP
The method returns the inflected form of the term candidate.
.SS "\fIgetPOS()\fP"
.IX Subsection "getPOS()"
.Vb 1
\&    getPOS();
.Ve
.PP
The method returns the list of the part-of-speech tags of the term
candidate.
.SS "\fIgetLF()\fP"
.IX Subsection "getLF()"
.Vb 1
\&    getLF();
.Ve
.PP
The method returns the canonical form (lemma) of the term candidate.
.SS "\fIgetID()\fP"
.IX Subsection "getID()"
.Vb 1
\&    getID();
.Ve
.PP
This method returns the identifier of the term candidate.
.SS "\fIbuildKey()\fP"
.IX Subsection "buildKey()"
.Vb 1
\&    buoldKey();
.Ve
.PP
This method builds the key of the testified term, i.e. the
concatenation of the inflected form, the postag list and the lemma
(separated by the character '~').
.SS "\fIgetSource()\fP"
.IX Subsection "getSource()"
.Vb 1
\&    getSource(),
.Ve
.PP
The method returns the terminological resource where the testified
term is issued.
.SS "\fIbuildRegularExpression()\fP"
.IX Subsection "buildRegularExpression()"
.Vb 1
\&    buildRegularExpression($match_type);
.Ve
.PP
The method computes the regular expression corresponding to the term
according to the type of matching defined by \f(CW$mach_type\fR. This
regular expression will be used to find the term in the corpus.
.SS "\fIgetRegExp()\fP"
.IX Subsection "getRegExp()"
.Vb 1
\&    getReqExp();
.Ve
.PP
The method returns the regular expression corresponding to the
testified term (field \f(CW\*(C`REG_EXP\*(C'\fR).
.SS "\fIgetWord()\fP"
.IX Subsection "getWord()"
.Vb 1
\&    getWord($index);
.Ve
.PP
The method returns the word at the position \f(CW\*(C`
index\*(C'\fR in the list of the components of the term candidate.
.SS "\fIaddOccurrence()\fP"
.IX Subsection "addOccurrence()"
.Vb 1
\&    addOccurrence($phrase_occurrence,$phrase,$key,$fh);
.Ve
.PP
This method looks for the current testified term with the occurrence
\&\f(CW\*(C`hrase_occurrence\*(C'\fR of the phrase \f(CW$phrase\fR (according to the key
\&\f(CW$key\fR). And then the occurrence is recorded in the list of
occurrences \f(CW\*(C`OCCURRENCES\*(C'\fR.  \f(CW$fh\fR is the  file
hanlder of a debugging file.
.SS "\fIgetPositionInPhrase()\fP"
.IX Subsection "getPositionInPhrase()"
.Vb 1
\&    getPositionInPhrase($phrase,$index_a,$fh);
.Ve
.PP
The method returns the position (start and end offsets) of the phrase
\&\f(CW$phrase\fR according to the index array \f(CW\*(C`index_a\*(C'\fR. \f(CW$fh\fR is the
file hanlder of a debugging file.
.SS "\fIsetIndexSet()\fP"
.IX Subsection "setIndexSet()"
.Vb 1
\&    setIndexSet($size);
.Ve
.PP
This method initialises the index set with the number betwwen 0 and
\&\f(CW$size\fR (usually the number of words).
.SS "\fIgetIndexSet()\fP"
.IX Subsection "getIndexSet()"
.Vb 1
\&    getIndexSet();
.Ve
.PP
This method returns the index set (field \f(CW\*(C`INDEX_SET\*(C'\fR) of the word components.
.SS "\fIgetOccurrences()\fP"
.IX Subsection "getOccurrences()"
.Vb 1
\&    getOccurrences();
.Ve
.PP
This method returns the list of the occurrences of the term candidate,
as an array reference.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sophie Aubin and Thierry Hamon. Improving Term Extraction with
Terminological Resources. In Advances in Natural Language Processing
(5th International Conference on \s-1NLP\s0, FinTAL 2006). pages
380\-387. Tapio Salakoski, Filip Ginter, Sampo Pyysalo, Tapio Pahikkala
(Eds). August 2006. \s-1LNAI\s0 4139.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thierry Hamon <thierry.hamon@univ\-paris13.fr> and Sophie Aubin <sophie.aubin@lipn.univ\-paris13.fr>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005 by Thierry Hamon and Sophie Aubin
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
